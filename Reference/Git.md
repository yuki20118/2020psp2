# Git

Git とは 一言でいうと，ディレクトリ木構造の変更履歴の同期ソフト　です．ディレクトリはフォルダでもいいです．

Gitの言葉で「 ディレクトリ木構造」をリポジトリと言います．ディレクトリの木構造とはディレクトリの中にディレクトリがあって，，，という入れ子の形のことで，
つまりは「レポジトリ」とは ，変更履歴を記憶し続ける「ディレクトリ」と考えてください．

## 1. Repository を作る

- 普通の既にある「ディレクトリ」を「レポジトリ」にするには，ディレクトリの中に変更履歴ディレクトリ（隠れディレクトリ）「`.git`」を作成します．レポジトリにしたいディレクトリを`hoge`とすると

```
git init hoge
```

もしくは，

```
cd hoge
git init
```

- 他の「レポジトリ」をコピーしてきてもいいです．他の「レポジトリ」の場所/名前を`foo`とすると

```
git clone foo
```

- 他の「レポジトリ」はインターネットの向こうかもしれません．そのときのコピーも

```
git clone https://URL/foo
```

- (GitHub)自分の領域がGitHubにあり，同じGithub上の他の「レポジトリ」をコピーしてくるときは，
GitHub上で，「Fork」

## 2. レポジトリのバックアップ

上記の「レポジトリの作成」は，レポジトリが新しく生まれます．ディレクトリがレポジトリとして再生します．他のレポジトリをコピーして自分のレポジトリが1つ生まれます．

ここでは，新しく生む話ではなく，すでにあるレポジトリAとレポジトリBがあって，Aの内容をBにバックアップする話です．

そのためには，それまでBには無かったAの内容をBに追加すればよい．どうやって追加されるかはBにまかせるとして，Bは元のBの内容もAの内容ももつことになります．これが AによるBへのpush (プッシュ；押しつけ)　です．

```
git push B
```

逆の立場のときもあります．Bとしては現在のBの姿に，Aの内容を吸収したい．それが BによるAのmerge（マージ；吸収合併）です．Bは変わり，Aは変わりません．

```
git merge A
```

プッシュは押し付けてるだけなので楽ですが，押し付けられる側のマージは難儀です． 「自分に無かった相手の内容を追加すればよい」と簡単にいうけれど，

- A「おはよう」
- B「こんばんは」

をどのようにマージすればいいか．「おはようこんばんは」か「おはこんばんは」か．ソースコードの文法の制約もあるのである程度スマートに自動的にマージできますが，あまりにときどきマージはサジを投げて人間様の助けを要求してきます．これが「conflict（コンフリクト；衝突）」です．コンフリクトの解決は本当に面倒です．

コンフリクトしないよう，内容が大きく異なるレポジトリはマージしない，バックアップであれば小さい単位でバックアップです．

### Aがインターネット上にあって，自分のマシンのBにバックアップしたいとき，

`git merge A`　ではなく，

```
git pull A
```

とします．

### レポジトリには名前をつける

AとB，どちらが働きかけるかの違いですが，いずれにせよこれでAの内容はBにバックされることになります．

書き忘れていましたが，`git push`，`git pull`は相手がインターネット上にいますので，レポジトリに名前をつけます．

```
git remote add origin https://www.github.com/helmenov/2020psp2
```

などです．このコマンドは，`https://www.github.com/helmenov/2020psp2`というレポジトリに`origin`という名前をつけて記憶するという意味です．

名前は`origin`でなくてもいいのですが，`origin`は慣例的にバックアップ先push,pull相手につける名前です．クローンしたときには，クローン元の親に`origin`という名前が自動的に付けられます．

push,pull時にはこの名前を使います．

```
git push origin

git pull origin
```


## 3. 変更履歴

さて，内容のバックアップは上記でいいとして，gitの特徴は変更履歴の記憶です．

### 変更履歴

変更履歴とは，

- ファイルを追加，消す．
- ファイル名が変える． 
- ファイルの中の記述が変わった．

この3つの状態の記憶です．

- 「ファイルを追加，消す」：正しくいうと，「ファイルを監視対象に追加，監視対象から外す」であって

```
git add fileA
git rm fileB
```

とします．fileAは監視対象外でしたが，これにより監視対象に入ります．fileBは監視対象になっていたが，これにより監視対象から外れます．git rmはファイル自体を削除するわけではありません．

逆に監視対象のファイルを削除したときは，手動でgitに変更を教えなければいけません．git restore fileBでfileBを復活させ，git rm fileBで監視対象から外します． 

- 「ファイル名を変える」：同様に「監視対象のファイル名を変える」です．ファイルの場所を変えるのもこの操作

```
git mv fileA fileB
```

gitのmvではなく，ふつうにファイル名を変えてしまうと，gitが監視対象を見失います．git restore fileAでfileAを復活させ，git rm fileAで監視対象から外して，git add fileBでリネーム後のファイルを監視対象に追加することになる気がします．

- 「ファイルの中の記述が変更された」：どんな変更でも

```
git add
```

です．

### 変更履歴の記録

変更履歴は記録するタイミングで整理されます．記録は

```
git commit
```

でその時点の変更履歴が整理されて記録されます．ファイルをaddしてrmしてaddした，その状態でcommitしたとき，結果としては1回のaddのみが記録されます．

ファイルの内容を変更した場合も，状態Xからちょっと変更して状態Yになりそれをaddして，また変更して状態Zになりそれをaddして，その状態でcommitすると，結果として状態Zと状態Xの差分が記録されます．状態Yはなかったことになります．

### 変更の巻き戻し

履歴があれば巻き戻せます．直前の状態に戻したいときは，

```
git restore fileA
```

です．

## まとめると

はじめるときは，既存ディレクトリAをレポジトリにするか(git init A)，他のレポジトリRをクローンするか(git clone R)してはじめます．
まずレポジトリがあります．状態I が記録されてます（無履歴かもしれないが）．
監視対象を追加したり，外したり，リネームしたり，編集したりします（git add, git rm, git mv, git add）.
ファイルaを編集したあとに状態I に記録されているaに戻したいときは，git restore a です．
記録したい状態IIになったら，コミットします．(git commit)
またいろいろやって状態IIIになったら，またコミットします．
Rにバックアップしたくなったら，プッシュします．(git push R)
RにはA以外のBのバックアップも入っているかもしれませんが，このRをAに吸収したいときは,プルします．(git pull)

## その他

### マージについて

- 同一マシン間のマージ：git merge A
- インターネット上のAをPCにマージ：git pull A

ですが，他に組み合わせとして

- PC上のAをインターネット上でマージ
- インターネット上の同じドメイン間でマージ

があります．前者はありません．後者はインターネット上のサーバマシンにログインして，そこで同一マシン間マージすればOKですが，ちょっと難儀です．

### フォークマージ

ところでGitHubでは，Forkという操作があり，同じGitHub内の他のレポジトリを自分の領域にクローンできました．（クローンはレポジトリマージではなく，レポジトリを新規作成する作業）

このフォークして作ったレポジトリには，cloneのときと同様に相手がいるわけで，当然マージしたくなります．さきほどの「同じドメイン間でマージ」です．難儀なので，次のように行います．

状況はこうです．

- G：GitHub上のレポジトリ（神様のものかも）
- R：神Gをフォークして作ったGitHub上のレポジトリ（自分のもの）
- A：Rをコピー(クローン)して作った自宅PC上のレポジトリ（当然自分のもの）

ふだんはAをいじっています．ときどきRにバックアップします(git push)．ときどきRとAを同期させます（git pull）．

ヒトRは昔々に神Gを真似て作られたものでした．その後，我が子Aの助けで独自の進化をとげ，大家族RXになりました．しかしそうこうしている間に神Gも進化し，GXとなっています．RXはGXを吸収したくなりました．やり方です．すべてAが指令します．

1. まず，AがRXを吸収します（ふだんから時々やってることです）．git pull R
2. 次に，AがGXを吸収します．git pull G
3. 次に，AがRXにプッシュします．git push
4. これにより，RXはGXの力を得ました．

これを実行するために，準備があります．ふだん見ていないインターネット上のGに名前をつけます．

```
git remote add upstream https://URL/G
git fetch upstream
```

です．
`git fetch upstream`はupstreamの名をつけたリポジトリの一次ダウンロードです．

Visual Studio Codeからターミナルを立ち上げ，上述の2つのコマンドを打ってください．
そうすると，ソース管理の画面で，
「指定元からプル」で upstream，ブランチはmasterを指定できます．
このプルにより，
手元のPCのフォルダは私のGithubと同じになります．（自分のGithubは未だ古い）
次に「プッシュ先」から origin，ブランチはmasterを指定し，手元のフォルダを自分のGithubにアップロードします．これで自分のGitHubが追いつきました．








今回のプログラミング演習２では，まず私の神レポジトリをフォークして自分のレポジトリをGithubに作ると思います．
私も課題をギリギリで作っているので，4月8日まではフォークしないでください．4月8日にフォークしてください．
それ以前にフォークしている人は，上記のフォークマージを行う必要があります．

よくわからない人は，フォークして作ったレポジトリを削除して，フォークからやり直してください．

